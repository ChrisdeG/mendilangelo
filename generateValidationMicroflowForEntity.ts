import { domainmodels, microflows, datatypes, texts, IModel, common } from "mendixmodelsdk";
import { findOrCreateModuleAndFolder, MicroflowExists } from "./findOrCreateModuleAndFolder";

// grid size
const deltaX = 160;
const deltaY = 130;
// starting X position
const fixedX = 70;
// horizontaal line / happy flow of microflow.
const fixedY = 80;


export function generateValidationMicroflowForEntity(model: IModel, domainModel: domainmodels.DomainModel, entityName: string, targetModule: string) {
    const folder = findOrCreateModuleAndFolder(model, domainModel.containerAsModule.name, targetModule, entityName);
    const variableName = 'Valid';
    const entity = domainModel.entities.filter((entity: domainmodels.Entity) => entity.name === entityName)[0];
    var booleanType = datatypes.BooleanType.create(model);

    let microflowName = entityName + "_Validate";
    if (!MicroflowExists(model, targetModule, microflowName, folder)) {
        console.log('Create validationmicroflow for', entityName);
        let microflow = microflows.Microflow.createIn(folder);
        microflow.name = microflowName
        microflow.microflowReturnType = booleanType;

        let annotation = microflows.Annotation.createIn(microflow.objectCollection);
        annotation.caption = "This microflow was automatically generated by Mendilangelo. Don't use this here but copy or move it to your own module.";
        annotation.relativeMiddlePoint = { x: fixedX + 2 * deltaX, y: fixedY - 100 };
        annotation.size = { width: 200, height: 100 };
        // inputparameter
        let inputparameter = microflows.MicroflowParameterObject.createIn(microflow.objectCollection);
        inputparameter.name = entityName;
        inputparameter.relativeMiddlePoint = { x: 70, y: -120 };
        // -- make it an object
        let inputObject = datatypes.ObjectType.createInMicroflowParameterObjectUnderVariableType(inputparameter);
        inputObject.entity = entity;

        // start event -> exclusive split
        let startEvent = microflows.StartEvent.createIn(microflow.objectCollection);
        startEvent.relativeMiddlePoint = { x: fixedX, y: fixedY };

        // create variable 'Validated'
        let createVariableAction = microflows.ActionActivity.createIn(microflow.objectCollection);
        createVariableAction.relativeMiddlePoint = { x: fixedX + deltaX, y: fixedY };
        let createVariable = microflows.CreateVariableAction.createIn(createVariableAction);
        let c = datatypes.BooleanType.createInCreateVariableActionUnderVariableType(createVariable);
        createVariable.initialValue = "true";
        createVariable.variableName = variableName;
        Connect(microflow, startEvent, 1, createVariableAction, 3);

        // starting position
        let leftX = fixedY + 2 * deltaX;
        // starting with variable.
        let prevBlock = <microflows.MicroflowObject>createVariableAction;

        // create validation for all attributes in array
        entity.attributes.forEach((attribute: domainmodels.Attribute) => {
            if (!attribute.name.startsWith("_") && (
                attribute.type instanceof domainmodels.EnumerationAttributeType ||
                attribute.type instanceof domainmodels.StringAttributeType ||
                attribute.type instanceof domainmodels.DateTimeAttributeType ||
                attribute.type instanceof domainmodels.DecimalAttributeType ||
                attribute.type instanceof domainmodels.IntegerAttributeType ||
                attribute.type instanceof domainmodels.LongAttributeType)) {
                prevBlock = createValidationBlock(microflow, prevBlock, entityName, attribute, leftX);
                leftX += 2 * deltaX;
            }
        }
        );

        // end event
        let endEvent = microflows.EndEvent.createIn(microflow.objectCollection);
        endEvent.relativeMiddlePoint = { x: leftX, y: fixedY };
        Connect(microflow, prevBlock, 1, endEvent, 3);
        endEvent.returnValue = "$" + variableName;
    }
}

function Connect(microflow: microflows.Microflow, fromFlow: microflows.MicroflowObject, indexFrom: number, toFlow: microflows.MicroflowObject, indexTo: number) {
    let connection = microflows.SequenceFlow.createIn(microflow);
    // 0  top, 1 right, 2 bottom, 3 left;
    const vector: common.ISize[] = [{ width: 0, height: -15 }, { width: 30, height: 0 }, { width: 0, height: 15 }, { width: -30, height: 0 }];
    const vectorstraight: common.ISize[] = [{ width: 0, height: -15 }, { width: 15, height: 0 }, { width: 0, height: 15 }, { width: -15, height: 0 }];
    connection.origin = fromFlow;
    connection.originConnectionIndex = indexFrom;
    connection.destination = toFlow;
    connection.destinationConnectionIndex = indexTo;
    // need to add vectors otherwise the editor is not valid
    // straight vector are shorter.
    if (indexFrom == 0 && indexTo == 2 || indexFrom == 1 && indexTo == 3) {
        connection.originBezierVector = vectorstraight[indexFrom];
        connection.destinationBezierVector = vectorstraight[indexTo];
    } else {
        connection.originBezierVector = vector[indexFrom];
        connection.destinationBezierVector = vector[indexTo];

    }
    return connection;
}


function createValidationBlock(microflow: microflows.Microflow, fromObject: microflows.MicroflowObject, entity: string, attribute: domainmodels.IAttribute, leftX: number) {

    // split
    let exclusiveSplit = microflows.ExclusiveSplit.createIn(microflow.objectCollection);
    exclusiveSplit.relativeMiddlePoint = { x: leftX, y: fixedY };
    exclusiveSplit.size = { width: 90, height: 60 };
    let splitCondition = microflows.ExpressionSplitCondition.createIn(exclusiveSplit);
    if (attribute.type instanceof domainmodels.StringAttributeType) {
        splitCondition.expression = `trim($${entity}/${attribute.name}) != ''`;
    } else {
        splitCondition.expression = `$${entity}/"${attribute.name} != empty`;
    }
    exclusiveSplit.caption = attribute.name;
    Connect(microflow, fromObject, 1, exclusiveSplit, 3);

    // change validated
    let changeValidated = microflows.ActionActivity.createIn(microflow.objectCollection);
    let changeVariable = microflows.ChangeVariableAction.createIn(changeValidated);
    changeVariable.changeVariableName = "Valid";
    changeVariable.value = "false";
    changeValidated.relativeMiddlePoint = { x: leftX, y: fixedY + deltaY };
    let connection = Connect(microflow, exclusiveSplit, 2, changeValidated, 0);
    // label false
    let caseFalse = microflows.EnumerationCase.createIn(connection);
    caseFalse.value = "false";

    // validation feedback
    let validationAction = microflows.ActionActivity.createIn(microflow.objectCollection);
    let validationFeedback = microflows.ValidationFeedbackAction.createIn(validationAction);
    validationFeedback.objectVariableName = entity;
    validationFeedback.attribute = attribute;
    let feedbackTemplate = microflows.TextTemplate.createInValidationFeedbackActionUnderFeedbackTemplate(validationFeedback);
    let feedbackTemplateText = texts.Text.createInTextTemplateUnderText(feedbackTemplate);
    let translation = texts.Translation.createIn(feedbackTemplateText);
    translation.languageCode = "en_US";
    translation.text = "Required";
    let translationNL = texts.Translation.createIn(feedbackTemplateText);
    translationNL.languageCode = "nl_NL";
    translationNL.text = "Verplicht";
    let translationGB = texts.Translation.createIn(feedbackTemplateText);
    translationGB.languageCode = "en_GB";
    translationGB.text = "Required";

    validationAction.relativeMiddlePoint = { x: leftX, y: fixedY + 2 * deltaY };
    Connect(microflow, changeValidated, 2, validationAction, 0);

    // merge action
    let merge = microflows.ExclusiveMerge.createIn(microflow.objectCollection);
    merge.relativeMiddlePoint = { x: leftX + deltaX, y: fixedY };
    let connection5 = Connect(microflow, exclusiveSplit, 1, merge, 3);

    // label true
    let casetrue = microflows.EnumerationCase.createIn(connection5);
    casetrue.value = "true";

    // feedback -> merge
    Connect(microflow, validationAction, 1, merge, 2);

    return merge;
}
